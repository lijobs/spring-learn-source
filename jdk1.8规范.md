#                                                             Java®语言规范

##                                               前言

​        1996年，James Gosling，Bill Joy和Guy Steele为Java®语言规范的第一版撰稿：

​       “我们相信Java编程语言是一种成熟的语言，可以广泛使用。尽管如此，我们期待未来几年语言的一些演变我们打算以与现有应用程序完全兼容的方式管理这种演变”。

​       Java SE 8代表了Java历史上最大的Java语言演变，相对较少的功能 - lambda表达式，方法引用和功能接口 - 相结合，提供融合面向对象和功能样式的编程模型。在Brian Goetz的领导下，这种融合已经以鼓励最佳实践 - 不变性，无状态，组合性 - 的方式完成，同时保留了“Java的感觉” - 可读性，简单性，普遍性。

​        至关重要的是，Java SE平台的库与Java语言共同发展，这意味着使用lambda表达式和方法引用来表示行为 - 例如，要应用于列表中每个元素的操作 - 具有生产性和高性能“开箱即用”。以类似的方式，Java虚拟机与Java语言共同发展，以确保默认方法在编译时间和运行时间内尽可能一致地支持库演化，考虑到单独编译的限制。

​       自20世纪90年代以来，我们围绕着为Java语言添加一流功能的举措而努力着。2007年左右的BGGA和CICE提案为该主题带来了新的活力，而2009年左右在OpenJDK创建的Lambda项目吸引了前所未有的兴趣。在Java SE 7中向JVM添加方法句柄为新的实现技术打开了大门，同时保留了“一次编写，随处运行”。随着时间的推移，JSR 335，用于Java编程语言的Lambda表达式监督语言变化，其专家组由Joshua Bloch，Kevin Bourrillion，Kevin Bourrillion，Andrey Breslav，RémiForax，Dan Heidinga，Doug Lea，Bob Lee，David Lloyd，Sam Pullara，Srikanth Sankaran和Vladimir Zakharov组成。

​        编程语言设计通常涉及到完全隐藏在语言用户之外的复杂程度。（因此，它经常与冰山相比：90％的冰山都是看不见的。）在JSR 335中，最大的复杂性潜伏在隐式类型的lambda表达式与重载决策的交互中。在这个以及许多其他领域，Oracle的Dan Smith在彻底指定所需行为方面做得非常出色。在整个说明书中都可以找到他的话，包括关于类型推理的全新章节。

​        Java SE 8中的另一项举措是增强注释的实用性，注释是Java语言最受欢迎的功能之一。首先，Java语法已经扩展到允许在许多语言结构中对类型进行注释，从而形成了新的***静态分析工具（如Checker Framework）***的基础。此功能由JSR 308，Java类型注释指定，由Michael Ernst和我自己的专家组Doug Lea和Srikanth Sankaran领导。本规范涉及的变化范围很广，Michael Ernst和Werner Dietl多年来不懈的努力得到了热烈的认可。其次，注释可以在语言结构上“重复”，以便使用注释类型为特定于域的配置建模的API带来很大好处。Java EE中的Michael Keith和Bill Shannon发起并指导了这一功能。

​        Oracle平台组的许多同事为此规范提供了有价值的支持:Leonid Arbouzov, Mandy Chung, Joe Darcy, Robert Field, Joel Borggrén-Franck, Sonali Goel, Jon Gibbons, Jeannette Hung, Stuart Marks, Eric McCorkle, Matherey Nunez, Mark Reinhold, Vicente Romero, John Rose, Georges Saab, Steve Sides, Bernard Traversat, and Michel Trudeau.

​        最重要的肯定是对于工程师而言将规范转变为真实软件的编译。Oracle的Maurizio Cimadamore从最初的lambda表达式设计及其在javac中的实现开始就英勇地工作。Eclipse中对Java SE 8功能的支持是由Jayaprakash Arthanareeswaran，Shankha Banerjee，Anirban Chakraborty，Andrew Clement，Stephan Herrmann，Markus Keller，JesperMøller，Manoj Palat，Srikanth Sankaran和Olivier Thomann;在Anna Kozlova，Alexey Kudravtsev和Roman Shevchenko的IntelliJ中。他们值得整个Java社区的感谢。

​        Java SE 8是Java语言的复兴。虽然有些人在寻找“下一个伟大的语言”，但我们相信Java编程比以往更令人兴奋和富有成效。我们希望它能继续为您服务。

## 1.简介

### [1.1 .组织规范](1.1组织规范)

### [1.2. 示例程序](1.2示例程序)

### [1.3. 符号](1.3符号)

### [1.4. 预定义类和接口的关系](预定义类和接口的关系)

### [1.5.反馈](1.5反馈)

## 2 语法

### [ 2.1.无上下文语法](2.1无上下文语法)

### [2.2.词汇语法](2.2词汇语法)

### [2.3. 句法语法](2.3句法语法)

### [2.4. 语法符号](2.4语法符号)

## 3 词汇结构

### [3.1. uniCode](3.1uniCode)

### [3.2. 词汇翻译](3.2. 词汇翻译)

### [3.3. Unicode Escapes](3.3. Unicode Escapes)

### [3.4. 输入元素和标记]()

### [3.5. 线路终结器](3.4. 线路终结器)

### [3.6. 白色空间](3.5. 白色空间)

### [3.7. 评论](3.7. 评论)

### [3.8. 身份标识](3.8. 身份标识)

### [3.9.关键词](3.9.关键词)

### [3.10. 字面](3.10. 字面)

#### [3.10.1 整数文字]( 3.10.1 整数文字)

#### [3.10.2.浮点文字](3.10.2.浮点文字)

####  [3.10.3.布尔文字](3.10.3.布尔文字)

####  [3.10.4. 字符文字](3.10.4. 字符文字)

#### [3.10.5.字符串文字](3.10.5.字符串文字)

####  [3.10.6转义字符和字符串文字的序列](3.10.6转义字符和字符串文字的序)

####  [3.10.7. Null 文字](3.10.7. Null Literal)

### [3.11.分离器](3.11分离器)

### [3.12. 运营](3.12. 运营)

## 4.类型，值和变量

### [4.1.类型和值的种类](类型和值的种类)

### [4.2.原始类型和值](4.2.原始类型和值)

#### [4.2.1 整体的类型和值](4.3. 整体的类型和值)

#### [4.2.2.整数运算](4.2.2. 整数运算)

#### [4.2.3. 浮点类型，格式和值](4.2.3. 浮点类型，格式和值)

#### [4.2.4. 浮点运算](4.2.4. 浮点运算)

#### [4.2.5.布尔类型和布尔值](4.2.5布尔类型和布尔值)

### [4.3. 引用类型和值](4.3. 引用类型和值)

#### [4.3.1 对象](4.3.1 对象)

#### [4.3.2 Object类](4.3.2 Object类)

#### [4.3.3 String类](4.3.3 String类)

#### [4.3.4 当引用类型相同时](4.3.4 当引用类型相同时)

### [4.4 变量类型](4.4 变量类型)

### [4.5.参数化类型](4.5.参数化类型)

#### [4.5.1 输入参数化类型的参数](4.5.1 输入参数化类型的参数)

#### [4.5.2 参数化类型的成员和构造者](4.5.2 参数化类型的成员和构造者)

### [4.6. 类型擦除](4.6. 类型擦除)

### [4.7. 可变类型](4.7. 可变类型)

### [4.8. 原始类型](4.8. 原始类型)

### [4.9. 交叉类型](4.9. 交叉类型)

### [4.10. 子类型](4.10. 子类型)

#### [4.10.1原始类型之间的子类型](4.10.1原始类型之间的子类型)

#### [4.10.2. 类和接口类型之间的子类型](4.10.2类和接口类型之间的子类型)

#### [4.10.3数组类型之间的子类型](4.10.3数组类型之间的子类型)

#### [4.10.4 最小上限](4.10.4最小上限 )

### [4.11. 使用类型的地方](4.11 使用类型的地方)

### [4.12 变量](4.12 变量)

#### [4.12.1. 原始类型的变量](4.12.1 原始类型的变量)

#### [4.12.2. 引用类型的变量](4.12.2 引用类型的变量)

#### [4.12.3 . 变量种类](4.12.3变量种类)

#### [4.12.4. final 变量](4.12.4 final 变量)

#### [4.12.5. 变量的初始值 ](4.12.5 变量的初始值)

#### [4.12.6. 类型，类和接口](4.12.6 类型，类和接口)

### [5. 转换和上下文](5. 转换和上下文)

#### [5.1. 各种转换](5.1 各种转换)

#### [5.1.1. 身份转换](5.1.1 身份转换)

#### [5.1.2. 扩大原始转换](5.1.2 扩大原始转换)

#### [5.1.3. 缩小原始转换](5.1.3 缩小原始转换 )

#### [5.1.4. 扩展和缩小原始转换 ](5.1.4 扩展和缩小原始转换)

#### [5.1.5. 扩大y引用转换 ](5.1.5 扩大y引用转换)

#### [5.1.6. 缩小引用转换](5.1.6 缩小引用转换)

#### [5.1.7. 强制转换](5.1.7 强制转换 )

#### [5.1.8. 拆箱转换](5.1.8 拆箱转换)

#### [5.1.9. 未经检查的转化](5.1.9 未经检查的转化)

#### [5.1.10. 捕获转换](5.1.10 捕获转换)

#### [5.1.11. 字符串转换](5.1.11 字符串转换)

#### [5.1.12.禁止转换 ](5.1.12 禁止转换)

#### [5.1.13. 集合值类型转换](5.1.13 集合值类型转换)

### [5.2. 分配上下文](5.2 分配上下文)

### [5.3. 调用上下文](5.3调用上下文)

### [5.4 .字符串上下文](5.4 .字符串上下文)

### [5.5. 抛出上下文](5.5. 抛出上下文)

#### [5.5.1. 构造引用类型](5.5.1构造引用类型)

#### [5.5.2.已检查的强制转换和未经检查的强制转换](5.5.2已检查的强制转换和未经检查的强制转换)

#### [5.5.3. 在运行时检查强制转换](5.5.3 在运行时检查强制转换)

### [5.6. 数字上下文](5.6 数字上下文)

#### [5.6.1. 一元数字提升 ](5.6.1 一元数字提升 )

#### [5.6.2. 提升二进制数字](5.6.2 提升二进制数字)

## [6. 命名](6. 命名)

### [6.1. 声明](6.1. 声明)

### [6.2. 名称和标识符](6.2. 名称和标识符)

### [6.3. 声明的范围](6.3. 声明的范围)

### [6.4. 阴影和遮蔽]([6.4. 阴影和遮蔽)

#### [6.4.1. 阴影](6.4.1 阴影)

#### [6.4.2. 模糊](6.4.2 模糊)

### [6.5. 确定名称的含义](6.5 确定名称的含义)

#### [6.5.1. 根据上下文对名称进行句法分类](6.5.1根据上下文对名称进行句法分类)

#### [6.5.2. 上下文不明确名称的重新分类](6.5.2上下文不明确名称的重新分类)

#### [6.5.3. 包名称的减少]([6.5.3. 包名称的减少])

##### [6.5.3.1. 简单的包名称 ](6.5.3.1 简单的包名称)

##### [6.5.3.2. 合格的包名称](6.5.3.2 合格的包名称)

### [6.5.4. 包或类型名称的含义](6.5.4 包或类型名称的含义)

#### [6.5.4.1.简单的包或类型名称](6.5.4.1 简单的包或类型名称)

#### [6.5.4.2. 合格的包裹或类型名称](6.5.4.2 合格的包裹或类型名称)

### [6.5.5. 类型名称的含义](6.5.5 类型名称的含义)

#### [6.5.5.1. 简单类型名称](6.5.5.1 简单类型名称)

#### [6.5.5.2. 合格的类型名称](6.5.5.2 合格的类型名称)

### [6.5.6 表达名称的含义](6.5.6 表达名称的含义)

#### [6.5.6.1. 简单的表达式名称](6.5.6.1. 简单的表达式名称)

#### [6.5.6.2. 合格的表达名称](6.5.6.2 合格的表达名称)

### [6.5.7.方法名称的含义](6.5.7 方法名称的含义)

#### [6.5.7.1 简单的方法命名](6.5.7.1 简单的方法命名)

### [6.6. 访问控制](6.6 访问控制)

#### [6.6.1 确定可访问性](6.6.1 确定可访问性)

#### [6.6.2. 受保护访问的详细信息](6.6.2. 受保护访问的详细信息)

##### [6.6.2.1. 访问受保护的成员](6.6.2.1. 访问受保护的成员)

##### [6.6.2.2. 对受保护构造函数的限定访问权限](6.6.2.2. 对受保护构造函数的限定访问权限)

### [6.7. 完全合格的名称和规范名称](6.7. 完全合格的名称和规范名称)

## [7. 包](7.包)

### [7.1. 包成员](7.1. 包成员)

### [7.2.主机支持包](7.2. 主机支持包)

### [7.3.编译单位](7.3.编译单位)

### [7.4. 包声明](7.4. 包声明)

#### [7.4.1. 包命名](7.4.1. 包命名)

#### [7.4.2. 未命名的包](7.4.2. 未命名的包)

#### [7.4.3. 包的可观察性](7.4.3. 包的可观察性)

### [7.5. 导入声明](7.5. 导入声明)

#### [7.5.1. 单一类型导入声明](7.5.1. 单一类型导入声明)

#### [7.5.2.类型导入按需声明](7.5.2.类型导入按需声明)

#### [7.5.3. 单静态导入声明](7.5.3. 单静态导入声明)

#### [7.5.4. 静态导入按需声明](7.5.4. 静态导入按需声明)

## [7.6. 顶级类型声明](7.6.顶级类型声明)

## [8.类](8.类)

### [8.1. 类声明](8.1. 类声明)

#### [8.1.1. 类修饰符](8.1.1. 类修饰符)

##### [8.1.1.1. 抽象类](8.1.1.1. 抽象类)

##### [8.1.1.2. final类](8.1.2. final类)

##### [8.1.1.3. strictfp类](8.1.1.3. strictfp类)

#### [8.1.2.通用类和类型参数](8.1.2.通用类和类型参数)

#### [8.1.3. 内部类和封闭实例](8.1.3. 内部类和封闭实例)

#### [8.1.4. 父类和子类](8.1.4. 父类和子类)

#### [8.1.5. 父接口](8.1.5. 父接口)

#### [8.1.6. 类主体和成员声明](8.1.6. 类主体和成员声明)

### [8.2. 类成员](8.2. 类成员)

### [8.3. 字段/属性声明](8.3. 字段/属性声明)

#### [8.3.1. 字段修饰符](8.3.1. 字段修饰符)

##### [8.3.1.1. 静态字段](8.3.1.1. 静态字段)

##### [8.3.1.2. final 字段](8.3.1.2. final 字段)

##### [8.3.1.3. 字段修饰符](8.3.1.3. 字段修饰符)

##### [8.3.1.4. 可见性字段](8.3.1.4. 可见性字段)

#### [8.3.2 字段初始化](8.3.2 字段初始化)

#### [8.3.3. 字段初始化期间的前向引用](8.3.3. 字段初始化期间的前向引用)

### [8.4. 方法声明](8.4. 方法声明)

#### [8.4.1. 形式参数](8.4.1. 形式参数)

#### [8.4.2. 方法签名](8.4.2. 方法签名)

#### [8.4.3. 方法修饰符](8.4.3. 方法修饰符)

##### [8.4.3.1. 抽象方法](8.4.3.1. 抽象方法)

##### [8.4.3.2. 静态方法](8.4.3.2. 静态方法)

##### [8.4.3.3. final方法](8.4.3.3. final方法)

##### [8.4.3.4. 本地方法](8.4.3.4. 本地方法)

##### [8.4.3.5. strictfp方法](8.4.3.5. strictfp方法)

##### [8.4.3.6. 同步方法](8.4.3.6. 同步方法)

#### [8.4.4. 通用方法](8.4.4. 通用方法)

#### [8.4.5. 方法结果](8.4.5. 方法结果)

#### [8.4.6. 抛出方法异常](8.4.6. 抛出方法异常)

#### [8.4.7. 方法体](8.4.7. 方法体)

#### [8.4.8. 继承，覆盖和隐藏](8.4.8. 继承，覆盖和隐藏)

##### [8.4.8.1. 覆盖（通过实例方法）](8.4.8.1. 覆盖（通过实例方法）)

##### [8.4.8.2. 隐藏（按类方法）](8.4.8.2. 隐藏（按类方法）)

##### [8.4.8.3. 覆盖和隐藏的要求](8.4.8.3. 覆盖和隐藏的要求)

##### [8.4.8.4. 使用覆盖等效签名继承方法](8.4.8.4. 使用覆盖等效签名继承方法)

#### [8.4. 9. 重载](8.4.9. 重载)

### [8.5. 成员类型声明](8.5. 成员类型声明)

#### [8.5.1. 静态成员类型声明](8.5.1. 静态成员类型声明)

### [8.6. 实例初始化器](8.6. 实例初始化器)

### [8.7. 静态初始化器](8.7. 静态初始化器)

### [8.8. 构造函数声明](8.8. 构造函数声明)

#### [8.8.1.形式参数](8.8.1.形式参数)

#### [8.8.2. 构造函数签名](8.8.2. 构造函数签名)

#### [8.8.3. 构造函数修饰符](8.8.3. 构造函数修饰符])

#### [8.8.4. 通用构造函数](8.8.4. 通用构造函数)

#### [8.8.5. 构造函数抛出异常](8.8.5. 构造函数抛出异常)

#### [8.8.6. 构造函数的类型](8.8.6. 构造函数的类型)

#### [8.8.7. 构造函数体](8.8.7. 构造函数体)

##### [8.8.7.1. 显式构造函数调用](8.8.7.1. 显式构造函数调用)

#### [8.8.8. 构造函数重载](8.8.8. 构造函数重载)

#### [8.8.9. 默认构造函数](8.8.9. 默认构造函数)

#### [8.8.10. 防止实例化](8.8.10. 防止实例化)

### [8.9. 枚举类型](8.9. 枚举类型)

#### [8.9.1. 枚举常量](8.9.1. 枚举常量)

#### [8.9.2. 枚举体声明](8.9.2. 枚举体声明)

#### [8.9.3. 枚举成员](8.9.3. 枚举成员)

## [9. 接口](9. 接口)

### [9.1. 接口声明](9.1. 接口声明)

#### [9.1.1. 接口修饰符](9.1.1. 接口修饰符)

##### [9.1.1.1. 抽象接口](9.1.1.1. 抽象接口)

##### [9.1.1.2. strictfp接口](9.1.1.2. strictfp接口)

#### [9.1.2. 通用接口和类型参数 ](9.1.2. 通用接口和类型参数 )

#### [9.1.3. 超级接口和子接口](9.1.3. 超级接口和子接口)

#### [9.1.4. 接口主体和成员声明](9.1.4. 接口主体和成员声明)

### [9.2. 接口成员](9.2. 接口成员)

### [9.3. 字段（常量）声明](9.3. 字段（常量）声明)

#### [9.3.1. 接口中字段的初始化 ](9.3.1. 接口中字段的初始化 )

### [9.4. 接口中方法声明](9.4. 接口中方法声明)

#### [9.4.1. 继承与覆盖](9.4.1. 继承与覆盖)

##### [9.4.1.1. 覆盖（通过实例方法）](9.4.1.1. 覆盖（通过实例方法）)

##### [9.4.1.2. 覆盖的要求](9.4.1.2. 覆盖的要求)

##### [9.4.1.3. 使用覆盖等效签名继承方法](9.4.1.3. 使用覆盖等效签名继承方法)

#### [9.4.2. 重载 ](9.4.2. 重载)

#### [9.4.3. 接口方法体](9.4.3. 接口方法体)

### [9.5. 成员类型声明](9.5. 成员类型声明)

### [9.6. 注解类型](9.6. 注释类型])

#### [9.6.1. 注解类型元素](9.6.1. 注解类型元素)

#### [9.6.2. 注解类型元素的默认值](9.6.2. 注解类型元素的默认值)

#### [9.6.3. 可重复的注解类型](9.6.3. 可重复的注解类型])

#### [9.6.4. 预定义的注解类型](9.6.4. 预定义的注解类型)

##### [9.6.4.1. @Teaget注解](9.6.4.1. @Teaget注解)

##### [9.6.4.2. @Retention注解](9.6.4.2. @Retention注解)

##### [9.6.4.3.  @Inherited注解](9.6.4.3.  @Inherited注解)

##### [9.6.4.4. @Override注解](9.6.4.4. @Override注解)

##### [9.6.4.5. @SuppressWarnings注解](9.6.4.5. @SuppressWarnings注解)

##### [9.6.4.6. @Deprecated注解](9.6.4.6. @Deprecated注解)

##### [9.4.6.7. @SafeVarargs注解]([9.4.6.7. @SafeVarargs注解)

##### [9.6.4.8. @Repeatable注解](9.6.4.8. @Repeatable注解)

##### [9.6.4.9. @FunctionalInterface注解](9.6.4.9. @FunctionalInterface注解)

### [9.7. 注解](9.7. 注解])

#### [9.7.1. 正常注解](9.7.1. 正常注解)

#### [9.7.2. 标记注解](9.7.2. 标记注解)

#### [9.7.3. 单元素注解](9.7.3. 单元素注解)

#### [9.7.4. 注解可能出现的位置](9.7.4. 注解可能出现的位置)

#### [9.7.5. 同一类型的多个注解](9.7.5. 同一类型的多个注解)

### [9.8. 功能接口](9.8. 功能接口)

### [9.9. 函数类型](9.9. 函数类型)

## [10. 数组](10. 数组)

### [10.1. 数组类型](10.1. 数组类型)

### [10.2. 数组变量](10.2. 数组变量)

### [10.3. 数组创建](10.3. 数组创建)

### [10.4. 访问数组](10.4. 访问数组)

### [10.5. 数组存储异常](10.5. 数组存储异常)

### [10.6. 数组初始化器](10.6. 数组初始化器)

### [10.7. 数组成员](10.7. 数组成员)

### [10.8. 数组的类对象](10.8. 数组的类对象)

### [10.9. 字符数组不是字符串](10.9. 字符数组不是字符串)

## [11. 异常](11. 异常)

### [11.1. 异常的种类和原因](11.1. 异常的种类和原因])

#### [11.1.1. 异常的种类](11.1.1. 异常的种类)

#### [11.1.2. 异常的原因](11.1.2. 异常的原因)

#### [11.1.3. 异步异常](11.1.3. 异步异常)

### [11.2. 编译时检查异常 ](11.2. 编译时检查异常)

#### [11.2.1. 表达式的异常分析](11.2.1. 表达式的异常分析)

#### [11.2.2. 声明的异常分析](11.2.2. 声明的异常分析)

#### [11.2.3. 异常检测](11.2.3. 异常检测)

### [11.3. 异常的运行时处理](11.3. 异常的运行时处理])

## [12. 执行](12. 执行)

### [12.1. Java虚拟机启动](12.1. Java虚拟机启动)

#### [12.1.1. 加载测试类](12.1.1. 加载测试类)

#### [12.1.2. 链接测试：验证，准备，（可选）解决](12.1.2. 链接测试：验证，准备，（可选）解决)

#### [12.1.3. 初始化测试：执行初始化器](12.1.3. 初始化测试：执行初始化器)

#### [12.1.4. 调用Test.main方法](12.1.4. 调用Test.main方法)

### [12.2. 加载类和接口](12.2. 加载类和接口)

#### [12.2.1. 加载过程](12.2.1. 加载过程)

### [12.3. 链接类和接口](12.3. 链接类和接口)

#### [12.3.1. 验证二进制表示](12.3.1. 验证二进制表示)

#### [12.3.2. 准备类或接口类型](12.3.2. 准备类或接口类型)

#### [12.3.3. 符号引用的解析](12.3.3. 符号引用的解析)

### [12.4. 类和接口的初始化](12.4. 类和接口的初始化)

#### [12.4.1. 发生初始化时](12.4.1. 发生初始化时)

#### [12.4.2. 详细的初始化程序](12.4.2. 详细的初始化程序)

### [12.5. 创建新的类实例](12.5. 创建新的类实例)

### [12.6. 完成类实例](12.6. 完成类实例)

#### [12.6.1. 最终实现](12.6.1. 最终实现)

#### [12.6.2. 与内存模型的交互](12.6.2. 与内存模型的交互)

### [12.7. 不加载类和接口](12.7. 不加载类和接口)

### [12.8. 程序退出](12.8. 程序退出)

## [13. 二进制兼容性](13. 二进制兼容性)

### [13.1. 二进制形式](13.1. 二进制形式)

### [13.2. 二进制兼容性是什么和不是什么](13.2. 二进制兼容性是什么和不是什么)

### [13.3. 包的演变](13.3. 包的演变)

### [13.4. 类的演变](13.4. 类的演变)

#### [13.4.1. 抽象类](13.4.1. 抽象类)

#### [13.4.2. final类](13.4.2. final类)

#### [13.4.3. public类](13.4.3. public类)

#### [13.4.4. 超类和超级接口 ](13.4.4. 超类和超级接口 )

#### [13.4.5. 类类型参数](13.4.5. 类类型参数)

#### [13.4.6. 类主体和成员声明](13.4.6. 类主体和成员声明])

#### [13.4.7. 访问成员和类的构造函数](13.4.7. 访问成员和类的构造函数)

#### [13.4.8. 字段声明](13.4.8. 字段声明)

#### [13.4.9. final字段和静态常量变量](13.4.9. final字段和静态常量变量)

#### [13.4.10. 静态字段](13.4.10. 静态字段)

#### [13.4.11. transient修饰的字段特性](13.4.11. transient修饰的字段特性)

#### [13.4.12. 方法和构造函数声明](13.4.12. 方法和构造函数声明)

#### [13.4.13. 方法和构造函数类型参数](13.4.13. 方法和构造函数类型参数)

#### [13.4.14. 方法和构造函数形式参数](13.4.14. 方法和构造函数形式参数)

#### [13.4.15. 方法结果类型](13.4.15. 方法结果类型)

#### [13.4.16. 抽象方法](13.4.16. 抽象方法)

#### [13.4.17. final方法](13.4.17. final方法)

#### [13.4.18. native方法](13.4.18. native方法)

#### [13.4.19. static方法](13.4.19. static方法)

#### [13.4.20. (synchronized)同步方法]((synchronized)同步方法)

#### [13.4.21. 方法和构造函数抛出](13.4.21. 方法和构造函数抛出)

#### [13.4.22. 方法和构造函数体](13.4.22. 方法和构造函数体)

#### [13.4.23. 方法和构造函数重载](13.4.23. 方法和构造函数重载)

#### [13.4.24. 方法重载](13.4.24. 方法重载)

#### [13.4.25. 静态初始化器](13.4.25. 静态初始化器)

#### [13.4.26. Enums的演变](13.4.26. Enums的演变)

### [13.5. 接口的演变](13.5. 接口的演变)

#### [13.5.1. ( public) 公共接口](public 公共接口)

#### [13.5.2. 超级接口](13.5.2. 超级接口)

#### [13.5.3. 接口成员](13.5.3. 接口成员)

#### [13.5.4. 接口类型参数](13.5.4. 接口类型参数)

#### [13.5.5. 接口字段声明](13.5.6. 接口字段声明)

#### [13.5.6. 接口方法声明 ](13.5.6. 接口方法声明 )

#### [13.5.7. 注解类型的演变](13.5.7. 注解类型的演变)

## [14. 块和语句](14. 块和语句)

### [14.1. 报表的常规和突发完成](14.1. 报表的常规和突发完成)

### [14.2. 块](14.2. 块)

### [14.3. 本地类声明](14.3. 本地类声明)

### [14.4. 局部变量声明语句](14.4. 局部变量声明语句)

#### [14.4.1. 局部变量声明符和类型 ](14.4.1. 局部变量声明符和类型 )

#### [14.4.2. 执行局部变量声明](14.4.2. 执行局部变量声明)

### [14.5. 声明](14.5. 声明)

### [14.6. 空陈述](14.6. 空陈述)

### [14.7. 标签语句](14.7. 标签语句)

### [14.8. 表达式陈述](14.8. 表达式陈述)

### [14.9. if语句](14.9. if语句)

#### [14.9.1. if-then声明](14.9.1. if-then声明)

#### [14.9.2. if-then-else语句](14.9.2. if-then-else语句)

### [14.10. 断言声明](14.10. 断言声明)

### [14.11. switch语句](14.11. switch语句)

### [14.12. while语句](14.12. while语句)

#### [14.12.1. 突然完成while语句](14.12.1. 突然完成while语句)

### [14.13. do语句](14.13. do语句)

#### [14.13.1. do语句瞬时完成](14.13.1. do语句瞬时完成)

### [14.14. The for Statement](14.14. The for Statement)

#### [14.14.1. for的基本声明](14.14.1. for的基本声明)

##### [14.14.1.1. for循环的初始化](14.14.1.1. for循环的初始化)

##### [14.14.1.2. for循环的迭代](14.14.1.2. for循环的迭代)

##### [14.14.1.3. for循环完成的瞬时态](14.14.1.3. for循环完成的瞬时态)

#### [14.14.2. for循环的增强声明](14.14.2. for循环的增强声明)

### [14.15. break声明](14.15. break声明)

### [14.16. continue声明](14.16. continue声明)

### [14.17. return声明](14.17. return声明)

### [14.18. throw 声明](14.18. throw 声明)

### [14.19. synchronized关键词的声明](14.19. synchronized关键词的声明)

### [14.20. try语句](14.20. try语句)

#### [14.20.1. 执行try-catch](14.20.1. 执行try-catch])

#### [14.20.2. 执行try-finally和try-catch-finally](14.20.2. 执行try-finally和try-catch-finally)

#### [14.20.3. try-with-resources语句](14.20.3. try-with-resources语句)

##### [14.20.3.1. 基本的Basic try-with-resources声明](14.20.3.1. 基本的Basic try-with-resources声明)

##### [14.20.3.2. try-with-resources的扩展](14.20.3.2. try-with-resources的扩展)

### [14.21. 无法访问的语句](14.21. 无法访问的语句)

## [15. 表达式](15. 表达式)

### [15.1. Evaluation, Denotation, and Result](15.1. Evaluation, Denotation, and Result)

### [15.2. 表达式的构成](15.2. 表达式的构成)

### [15.3. 表达式的类型](15.3. 表达式的类型)

### [15.4. FP严格表达式]()

### [15.5. 表达式和运行时检查](15.5. 表达式和运行时检查)

### [15.6.]()



